@Pulse:
IF spacing IS UNDEFINED
 spacing := 360 / BLINKP.NUM_PIXELS
 hue := 0
 pixels_data := []
 n := BLINKP.NUM_PIXELS
 REPEAT n
  x := BLINKP.NUM_PIXELS-n-1
  h := ((hue + x*spacing) % 360) / 360
  r, g, b := BLINKP.HSV_TO_RGB(h, 1.0, 1.0)
  r := MATH.ROUND(r * 255)
  g := MATH.ROUND(g * 255)
  b := MATH.ROUND(b * 255)
  pixels_data.PUSH [r, g, b, 1]
  BLINKP.SET_PIXEL(x, pixels_data[x][0], pixels_data[x][1], pixels_data[x][2], pixels_data[x][3]/10)
 ENDREP
 max_brightness := 10
 goal :~ max_brightness
 goal += 1
 dir := 1
 delay := 1 / BLINKP.NUM_PIXELS
ENDIF
n := pixels_data.LENGTH-1
REPEAT n
 pixels_data[n+1][3] := pixels_data[n][3]
ENDREP
brightness := pixels_data[0][3]
incr :~ max_brightness*3/10
brightness += incr * dir
IF dir > 0
 IF brightness >= goal
  brightness := goal
  goal :~ max_brightness
  goal += 1
  IF goal < brightness
   dir *= -1
  ENDIF
 ENDIF
ELSE
 IF brightness <= goal
  brightness := goal
  goal :~ max_brightness
  goal += 1
  IF goal > brightness
   dir *= -1
  ENDIF
 ENDIF
ENDIF
pixels_data[0][3] := brightness
n := BLINKP.NUM_PIXELS
REPEAT n
 BLINKP.SET_PIXEL(n, pixels_data[n][0], pixels_data[n][1], pixels_data[n][2], pixels_data[n][3]/10)
ENDREP
BLINKP.SHOW_AND_WAIT(delay)
